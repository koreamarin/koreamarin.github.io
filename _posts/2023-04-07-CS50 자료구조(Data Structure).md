---
layout: post
title: CS50 자료구조(Data Structure)
description: CS50 자료구조(Data Structure)
date: 2023-04-07 00:00:00 +0000
categories: ComputerScience # Develop, Life, DevOps, Conference, BackEnd, AI, Etc, retrospect, Algorihtm
comments: true
type: done # done, writing, hide
---

CS50 강의를 듣고 자료구조 수업내용을 정리한 내용입니다.

# 컴퓨팅 사고

### 2진법

10진법을 2진법으로 표현하는 방법과 2진법이 무엇인지에 대해 설명하였음.
비트가 무엇인지 설명하였고, 비트열에 대해 설명하였음.(비트열이 8개면 바이트)

### 정보의 표현

문자를 이진으로 표현하기 위한 ASCII 코드, 유니코드에 대해 듣게됨.

색과 소리 또한 이진법으로 표현된 다는 것을 듣게됨(RGB)

### 알고리즘

**알고리즘과 의사코드가 무엇인지에 대해 배우는 강의**

알고리즘이 무엇인지에 대해 이진검색을 예로 들어 알려주었다.

의사코드가 무엇인지에 대해 알려주었다.

의사코드는 필요한 행동이나 조건을 잘 설정하여 컴퓨터가 수행해야 하는 일을 절차적으로 파악할 수 있게 도와주는 코드이다. 컴퓨터에게 알려주는 것이 아니라 사람에게 알려주는 것이다.

![image](/image/CS50자료구조1.jpg)

빨간색은 함수라고 불리는 것으로 사람 / 컴퓨터에게 무엇을 할지 알려주는 동사와 같다.
초록색은 조건이라고 부르는 것으로 여러 선택지 중 하나를 고르는 것이다.
보라색은 불리언(boolean)으로 답이 참 또는 거짓으로 나오면 2진법에서 0 또는 1로 나오는 질문은 뜻함.
빨간색 배경은 루프(loop)라고 함. 뭔가를 반복하는 순환기능.

---

# C언어

### C기초

c언어를 사용하기 위한 기초를 배우는 강의

C언어를 작성할 때 소스코드를 우리는 인간이 읽을 수 있는 코드라고 하여 **휴먼코드**라고 부름.
C언어로 작성한 파일을 사용하기 위해서는 “파일이름.c”로 저장해야 함.
이렇게 작성한 코드를 컴파일을 해야하는데 C언어는 “clang”이라는 컴파일러를 가지고 있음. 이 clang이라는 컴파일러가 우리의 소스코드를 컴파일 해줌.

```c
clango 파일이름.c
```

위와 같은 명령어를 커맨드에 입력하여 컴파일을 하고 컴파일된 파일을 생성함.
a.out 파일이 생성됨. 여기에는 컴퓨터가 이해할 수 있는 **머신코드**가 들어있음.

```c
./a.out
```

위와 같은 명령어를 커맨드에 다시 입력하면 컴파일된 파일을 실행시키면서 우리가 만들었던 소스코드가 실행됨.

### 문자열

문자열을 다루는 기초를 학습한다.

```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
	string answer = get_string("What's your name?\n");
	printf("hello, %s\n"), answer);
}
```

<br>
```c
make hello
```

커맨드에 위와같이 clang을 쓰지 않고 **make 파일명** 을 적으면 컴파일된 파일이 만들어진다. make가 더 편해서 많이 쓰인다고 한다.

### 조건문과 루프

조건문과 반복문에 대해서 알려준 강의

```c
if (x<y)
{
	printf("x is less than y\n");
}
else if (x>y)
{
	printf("x is greater than y\n");
}
```

<br>
```c
while(true)
{
	printf("hello, world\n");
}
```
<br>
```c
for (int i = 0; i< 50; i++) {
	printf("hello, world\n");
}
```

### 자료형, 형식 지정자, 연산자

자료형과 형식지정자, 연산자에 대해 알려주는 강의

**데이터 타입**

아래 목록은 변수의 데이터 타입으로 사용할 수 있는 것들입니다.

- bool: 불리언 표현, (예) True, False, 1, 0, yes, no
- char: 문자 하나 (예) 'a', 'Z', '?'
- string: 문자열
- int: 특정 크기 또는 특정 비트까지의 정수 (예) 5, 28, -3, 0
- long: 더 큰 크기의 정수
- float: 부동소수점을 갖는 실수 (예) 3.14, 0.0, -28.56
- double: 부동소수점을 포함한 더 큰 실수

**자료형과 형식지정자**

bool, char (%c), double (%f), float (%f), int (%i), long (%li), string (%s)

**기타 연산자 및 주석**

그 외에도 아래 목록과 같이 다양한 수학 연산자, 논리 연산자, 주석 등이 기호로 정의되어 있습니다.

- +: 더하기
- : 빼기
- : 곱하기
- /: 나누기
- %: 나머지
- &&: 그리고
- &#124;&#124;: 또는
- //: 주석

### 사용자 정의 함수, 중첩 루프

사용자 정의함수 void, int 등의 자료형을 가진 함수를 만드는 방법과, 중첩루프에 대해서 알아보는 강의

### 하드웨어의 한계

메모리는 유한하기 떄문에 아주 큰 수나, 작은 소수점이나 같은 것들을 아주 정교하게 계산할수는 없다. 컴퓨터가 유한한 메모리로 계산하였을때, 가장 가까운 근사치를 보여주는 것이다.

메모리를 벗어나 부정확한 답을 도출하는 것을 **오버플로우** 라고 한다.

---

# 배열

### 컴파일링

**make나 clang을 사용해서 프로그램을 실행할 때** 전처리, 컴파일링, 어셈블링, 링킹 **네 개의 단계를 거칩니다.**

#### **전처리(Precompile)**

**컴파일의 전체 과정은 네 단계로 나누어볼 수 있습니다**. 그 중 첫 번째 단계는 **전처리**인데, 전처리기에 의해 수행됩니다. # 으로 시작되는 C 소스 코드는 전처리기에게 **실질적인 컴파일이 이루어지기 전에 무언가를 실행**하라고 알려줍니다.
예를 들어, #include는 전처리기에게 다른 파일의 내용을 포함시키라고 알려줍니다. 프로그램의 소스 코드에 #include 와 같은 줄을 포함하면, 전처리기는 새로운 파일을 생성하는데 이 파일은 여전히 C 소스 코드 형태이며 stdio.h 파일의 내용이 #include 부분에 포함됩니다.

#### **컴파일(Compile)**

전처리기가 전처리한 소스 코드를 생성하고 나면 그 다음 단계는 **컴파일**입니다. **컴파일러**라고 불리는 프로그램은 **C 코드를 어셈블리어라는 저수준 프로그래밍 언어로 컴파일**합니다.
**어셈블리**는 C보다 연산의 종류가 훨씬 적지만, 여러 연산들이 함께 사용되면 C에서 할 수 있는 모든 것들을 수행할 수 있습니다. C 코드를 어셈블리 코드로 변환시켜줌으로써 컴파일러는 컴퓨터가 이해할 수 있는 언어와 최대한 가까운 프로그램으로 만들어 줍니다. 컴파일이라는 용어는 소스 코드에서 오브젝트 코드로 변환하는 전체 과정을 통틀어 일컫기도 하지만, 구체적으로 전처리한 소스 코드를 어셈블리 코드로 변환시키는 단계를 말하기도 합니다.

#### **어셈블(Assemble)**

소스 코드가 어셈블리 코드로 변환되면, 다음 단계인 **어셈블** 단계로 **어셈블리 코드를 오브젝트 코드로 변환**시키는 것입니다. 컴퓨터의 중앙처리장치가 프로그램을 어떻게 수행해야 하는지 알 수 있는 명령어 형태인 **연속된 0과 1들로 바꿔주는 작업**이죠. 이 변환작업은 **어셈블러**라는 프로그램이 수행합니다. 소스 코드에서 오브젝트 코드로 컴파일 되어야 할 파일이 딱 한 개라면, 컴파일 작업은 여기서 끝이 납니다. 그러나 그렇지 않은 경우에는 링크라 불리는 단계가 추가됩니다.

#### **링크(Link)**

만약 프로그램이 (math.h나 cs50.h와 같은 라이브러리를 포함해) **여러 개의 파일로 이루어져 있어 하나의 오브젝트 파일로 합쳐져야 한다면** **링크**라는 컴파일의 마지막 단계가 필요합니다. 링커는 여러 개의 다른 오브젝트 코드 파일을 실행 가능한 하나의 오브젝트 코드 파일로 합쳐줍니다. 예를 들어, 컴파일을 하는 동안에 CS50 라이브러리를 링크하면 오브젝트 코드는 GetInt()나 GetString() 같은 함수를 어떻게 실행할 지 알 수 있게 됩니다.

이 네 단계를 거치면 최종적으로 실행 가능한 파일이 완성됩니다.

### 디버깅

#### **버그**

**버그(bug)**는 **코드에 들어있는 오류**입니다. 버그로 인해 프로그램의 실행에 실패하거나 프로그래머가 원하는 대로 동작하지 않게 됩니다. 버그를 만들고 싶지 않겠지만 모든 프로그래머들은 버그와 마주하게 되어있습니다.

#### **디버깅**

**디버깅(debugging)**은 **코드에 있는 버그를 식별하고 고치는 과정**입니다. 프로그래머는 **디버거**라고 불리는 프로그램을 사용하여 디버깅을 하게 됩니다.
프로그램은 일반적으로 인간보다 훨씬 빠르게 연산을 수행합니다. 그래서 프로그램을 실행시켜보는 것만으로는 무엇이 잘못됐는지 찾아내기 어렵습니다. **디버거는 프로그램을 특정 행에서 멈출 수 있게 해주기 때문에 버그를 찾는데 도움이 됩니다.** 프로그래머는 멈춰진 그 지점에서 무슨 일이 일어나는지 볼 수 있습니다. **프로그램이 멈추는 특정 지점**을 **중지점**이라고 합니다. 또한 **프로그래머가 프로그램을 한번에 한 행씩 실행할 수 있게 해줍니다.** 이로써 프로그래머는 프로그램이 내리는 모든 결정들을 단계별로 따라갈 수 있게 됩니다.

#### **help50**

아래 코드를 컴파일하고 실행한다고 생각해봅시다.

```c
int main(void)
{
    printf("hello, world\n");
}
```

make 프로그램을 이용하여 컴파일해보면 “implicitly declaring library function 'printf'” 이라는 에러 메시지가 나타납니다.
이런 에러 메시지를 이해하기 힘들다면, **help50 프로그램**을 사용해보세요.
아래와 같이 make 앞에 help50 을 붙여서 실행하면 다시 컴파일시 생기는 오류를 해석해줍니다.

```c
help50 make 파일이름
```

문제의 원인은 printf 함수를 사용하기 위해서 stdio.h 라이브러리를 포함해야 한다는 것이었죠.

### 배열(1)

#### **메모리**

C에는 아래와 같은 여러 자료형이 있고, 각각의 자료형은 서로 다른 크기의 메모리를 차지합니다.

- bool: 불리언, 1바이트
- char: 문자, 1바이트
- int: 정수, 4바이트
- float: 실수, 4바이트
- long: (더 큰) 정수, 8바이트
- double: (더 큰) 실수, 8바이트
- string: 문자열, ?바이트
  컴퓨터 안에는 아래 사진과 같은 **RAM** 이라고 하는 물리적 칩이 메모리 역할을 합니다.
  쉽게 생각하면 아래 사진에서 여러 개의 노란색 사각형이 메모리를 의미하고, 작은 사각형 하나가 **1바이트**를 의미한다고 볼 수 있습니다.
  ![image](https://cs50.harvard.edu/x/2020/notes/2/ram.png)  
  예를 들어 char 타입의 변수를 하나 생성하고, 그 값을 입력한다고 하면 위 사진에서 한 사각형 안에 그 변수의 값이 저장되는 것이죠.

#### **배열**

아래와 같이 세 개의 점수를 저장하고 그 평균을 출력하는 프로그램이 있습니다.

```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // Scores
    int score1 = 72;
    int score2 = 73;
    int score3 = 33;

    // Print average
    printf("Average: %i\n", (score1 + score2 + score3) / 3);
}
```

만약 점수의 개수가 더 많아진다면 이 프로그램은 많은 부분을 수정해줘야 합니다.  
이 때 활용할 수 있는 것이 배열의 개념입니다.  
배열은 같은 자료형의 데이터를 메모리상에 연이어서 저장하고 이를 하나의 변수로 관리하기 위해 사용됩니다.  
위 코드는 배열을 이용하면 아래와 같이 바꿀 수 있습니다.

```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // Scores
    int scores[3];
    scores[0] = 72;
    scores[1] = 73;
    scores[2] = 33;

    // Print average
    printf("Average: %i\n", (scores[0] + scores[1] + scores[2]) / 3);
}
```

**int scores[3];** 이라는 코드는 int 자료형을 가지는 크기 3의 배열을 scores 라는 이름으로 생성하겠다는 의미입니다.  
배열의 인덱스는 0부터 시작하기 때문에, scores의 인덱스는 0, 1, 2 세 개가 있습니다.  
이 인덱스를 변수명 뒤 대괄호 [ ] 사이에 입력하여 배열의 원하는 위치에 원하는 값을 저장하고 불러올 수 있습니다.  
하지만 위와 같은 코드는 여전히 점수의 개수가 바뀌는 상황에서 제약이 많습니다.  
다음 강의에서는 배열을 보다 동적으로 선언하고 저장하는 방법을 알아보겠습니다.

### 배열(2)

#### **전역 변수**

이전 강의에 이어서, 아래 코드에서 scores 배열의 크기를 정해주는 N이라는 변수를 새로 선언하였습니다.  
만약 N이 고정된 값(상수)이라면 그 값을 선언할 때 const를 앞에 붙여서 전역 변수, 즉 코드 전반에 거쳐 바뀌지 않는 값임을 지정해줄 수 있습니다.  
관례적으로 이런 전역 변수의 이름은 대문자로 표기 합니다.

```c
#include <cs50.h>
#include <stdio.h>
const int N = 3;

int main(void)
{
    // 점수 배열 선언 및 값 저장
    int scores[N];
    scores[0] = 72;
    scores[1] = 73;
    scores[2] = 33;

    // 평균 점수 출력
    printf("Average: %i\n", (scores[0] + scores[1] + scores[2]) / N);
}
```

scores의 크기로 전역 변수를 선언하였기 때문에 점수 개수가 바뀌었을때 수정해야 하는 코드가 조금 줄었습니다.  
하지만 여전히 일일이 배열의 인덱스마다 점수를 지정해줘야 하는 불편함이 있습니다.

#### **배열의 동적 선언 및 저장**

아래 코드에서와 같이 루프와 함수를 선언하여 좀 더 동적인 프로그램을 작성할 수 있습니다.

```c
#include <cs50.h>
#include <stdio.h>

float average(int length, int array[]);

int main(void)
{
    // 사용자로부터 점수의 갯수 입력
    int n = get_int("Scores:  ");

    // 점수 배열 선언 및 사용자로부터 값 입력
    int scores[n];
    for (int i = 0; i < n; i++)
    {
        scores[i] = get_int("Score %i: ", i + 1);
    }

    // 평균 출력
    printf("Average: %.1f\n", average(n, scores));
}

//평균을 계산하는 함수
float average(int length, int array[])
{
    int sum = 0;
    for (int i = 0; i < length; i++)
    {
        sum += array[i];
    }
    return (float) sum / (float) length;
}
```

여기서는 배열의 크기를 사용자에게 직접 입력 받고, 배열의 크기만큼 루프를 돌면서 각 인덱스에 해당하는 값을 역시 사용자에게 동적으로 입력 받아 저장합니다.  
그리고 average 라는 함수를 따로 선언하여 평균을 구합니다.  
average 함수는 length 와 array[], 즉 배열의 길이와 배열을 입력으로 받습니다. 함수 안에서는 배열의 길이만큼 루프를 돌면서 값의 합을 구하고 최종적으로 평균값을 반환합니다.  
이와 같은 방법을 통해서 임의의 점수 개수와 점수 배열에 대해서 동적으로 평균값을 구하는 프로그램을 작성할 수 있습니다.

### 문자열과 배열

우리가 여지껏 사용한 문자열(string) 자료형의 데이터는 사실 문자(char) 자료형의 데이터들의 배열이었습니다.

**string s = “HI!”;** 과 같이 문자열 s가 정의되어 있다고 생각해봅시다.

s는 문자의 배열이기 때문에 메모리상에 아래 그림과 같이 저장되고, 인덱스로 각 문자에 접근할 수 있습니다.

![image](https://cs50.harvard.edu/x/2020/notes/2/memory_with_string.png)

여기서 가장 끝의 **‘\0’**은 문자열의 끝을 나타내는 널 **종단 문자**입니다.

단순히 모든 비트가 0인 1바이트를 의미합니다.

**종단문자는 문자열의 끝을 알리기 위해서 필요한 문자입니다.**

그럼 아래 코드와 같이 여러 문자열이 동시에 선언된 경우를 살펴보겠습니다.

```c
string names[4];

names[0] = "EMMA";
names[1] = "RODRIGO";
names[2] = "BRIAN";
names[3] = "DAVID";

printf("%s\n", names[0]);
printf("%c%c%c%c\n", names[0][0], names[0][1], names[0][2], names[0][3]);

```

names라는 문자열 형식의 배열에 네 개의 이름이 저장되어있습니다.

첫 번째 printf에서는 names의 첫번째 인덱스의 값, 즉 “EMMA”를 출력합니다.

두 번째 printf에서는 형식 지정자가 %s가 아닌 %c로 설정되어 있음을 확인할 수 있습니다.

따라서 출력하는 것은 문자열이 아닌 문자입니다.

여기서는 각 이름의 두번째 문자를 출력하고자 합니다.

이는 names[0][1]과 같이 2차원 배열을 통해 접근할 수 있습니다.

다시 말해 names[0][1]는 names의 첫 번째 값, 즉 “EMMA”라는 문자열에서, 그 두번째 값, 즉 ‘M’ 이라는 문자를 의미합니다.

아래 그림에서 names가 실제 메모리상에 저장된 예시와 해당하는 인덱스를 확인할 수 있습니다.

![image](https://cs50.harvard.edu/x/2020/notes/2/memory_with_string_array.png)

### 문자열의 활용

#### **문자열의 길이 및 탐색**

사용자로 부터 문자열을 입력받아 한 글자씩 출력하는 프로그램을 만들어 보겠습니다.  
 간단하게 for 루프를 통해 문자열의 인덱스를 하나씩 증가시켜가면서 해당하는 문자를 출력하면 될텐데요, 문자열의 끝은 어떻게 알 수 있을까요?  
 한가지 방법은 해당하는 인덱스의 문자가 널 종단 문자, 즉 ‘\0’와 일치하는지 검사하는 것입니다.  
 즉, s라는 문자열이 있다고 할 때 for (int i = 0; s[i] != ‘\0’; i++) { ..} 과 같은 루프를 사용하면 되겠죠.  
 하지만 아래 코드와 같이 strlen() 이라는 함수를 사용할 수도 있습니다.

```c
#include <cs50.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    string s = get_string("Input: ");
    printf("Output:\n");
    for (int i = 0, n = strlen(s); i < n; i++)
    {
        printf("%c\n", s[i]);
    }
}
```

**strlen**은 문자열의 길이를 알려주는 함수로, string.h 라이브러리 안에 포함되어 있습니다.  
위 코드에서는 n이라는 변수에 문자열 s의 길이를 저장하고, 해당 길이 만큼만 for 루프를 순환합니다.  
따라서 일일이 널 종단 문자를 검사하는 것 보다 훨씬 효율적입니다.

#### **문자열 탐색 및 수정**

사용자로부터 문자열을 입력받아 대문자로 바꿔주는 프로그램을 아래와 같이 작성할 수 있습니다.

```c
#include <cs50.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    string s = get_string("Before: ");
    printf("After:  ");
    for (int i = 0, n = strlen(s); i < n; i++)
    {
        if (s[i] >= 'a' && s[i] <= 'z')
        {
            printf("%c", s[i] - 32);
        }
        else
        {
            printf("%c", s[i]);
        }
    }
    printf("\n");
}
```

먼저 사용자로부터 입력받은 문자를 s라는 변수에 저장합니다.  
그리고 s의 길이만큼 for 루프를 돌면서, 각 인덱스에 해당하는 문자가 ‘a’보다 크고 ‘z’보다 작은지 검사합니다.  
즉, 소문자인지 검사하는 것과 동일합니다.  
여기서 문자의 대소비교가 가능한 이유는 ASCII값, 즉 그 문자가 정의되는 ASCII 코드 상에서의 숫자값으로 비교할 수 있기 때문입니다.  
또한 알파벳의 ASCII 값을 잘 살펴보면 각 알파벳의 소문자와 대문자는 32씩 차이가 남을 확인할 수 있습니다.  
따라서 각 문자가 소문자인 경우 그 값에서 32를 뺀 후에 ‘문자’ 형태로 출력하면 대문자가 출력이 됩니다.  
각 문자가 이미 대문자인 경우는 그냥 그대로 출력하면 됩니다.  
이와 동일한 작업을 수행하는 함수가 ctype 라이브러리에 **toupper()** 이라는 함수로 정의되어 있습니다.  
이를 이용하면 간단하게 아래와 같이 대문자 변환 프로그램을 작성할 수 있습니다.

```c
#include <cs50.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    string s = get_string("Before: ");
    printf("After:  ");
    for (int i = 0, n = strlen(s); i < n; i++)
    {
        printf("%c", toupper(s[i]));
    }
    printf("\n");
}
```

### 명령행 인자

우리가 여태껏 많이 사용해온 main 함수를 보다 자세히 들여다볼 때가 왔습니다.

main도 그 형태를 보면 하나의 함수임을 알 수 있는데요, 이젠 더이상 main() 안에 기계적으로 void 라고 입력하는 대신 아래 코드와 같이 argc, argv 를 정의해보겠습니다.

```c
#include <cs50.h>
#include <stdio.h>

int main(int argc, string argv[])
{
    if (argc == 2)
    {
        printf("hello, %s\n", argv[1]);
    }
    else
    {
        printf("hello, world\n");
    }
}
```

여기서 첫번째 변수 **argc**는 main 함수가 받게 될 **입력의 개수**입니다.

그리고 **argv[]**는 그 **입력이 포함되어 있는 배열**입니다. 프로그램을 명령행에서 실행하므로, 입력은 문자열로 주어집니다.

따라서 argv[]는 string 배열이 됩니다.

**argv[0]**는 기본적으로 **프로그램의 이름**으로 저장됩니다.

만약 하나의 입력이 더 주어진다면 argv[1]에 저장될 것입니다.

예를 들어 위 프로그램을 “arg.c”라는 이름으로 저장하고 컴파일 한 후 **“./argc”**로 실행해보면 “hello, world”라는 값이 출력됩니다.

명령행 인자에 주어진 값이 프로그램 이름 하나밖에 없기 때문입니다.

하지만 **“./argc David”**로 실행해보면 “hello, David”라는 값이 출력됩니다.

명령행 인자에 David라는 값이 추가로 입력되었고, 따라서 argc 는 2, argv[1] 은 “David”가 되기 때문입니다.

---

# 메모리

### 메모리 주소

#### **16진수**

컴퓨터과학에서는 숫자를 10진수나 2진수 대신 **16진수(Hexadecimal)**로 표현하는 경우가 많습니다. 컴퓨터에서 데이터를 처리하기 위해 16진수를 사용할 때 장점이 있기 때문입니다. 16진수와 일상생활에서 우리가 사용하는 10진수와 비교하면 그 차이를 알 수 있습니다. 16진수를 사용하면 10진수보다 2진수를 간단하게 나타낼 수 있습니다. 16진수로 값을 표현하는 방법을 이해하고 나면 16진수, 2진수, 10진수를 변환하는 프로그램을 만들어볼 수 있습니다.

#### **10진수를 16진수로 바꾸어보기**

JPG 이미지 파일은 항상 255 216 255 로 시작되고 이것은 10진수입니다. 하지만 실제 컴퓨터 내에서는 10진수를 사용하지 않습니다. 컴퓨터는 0과 1만을 이해할 수 있기 때문입니다.  
![image](https://cphinf.pstatic.net/mooc/20170807_218/1502072784893AgAug_PNG/5.4_-01.png?type=w760)  
**그림 1**  
<br>
먼저 255 216 255를 2진수로 나타내보면 <그림 1>과 같습니다. 2진수로 모든 데이터를 표현하기에는 너무 길어지기 때문에 16진수로 바꾸어 보겠습니다. 2^424  
**이 16이기 때문에 4bits씩** 두 덩어리로 나누어 보면 0000 부터 1111까지는 16진수로 표현할 수 있다는 것을 알 수 있습니다.  
그렇다면 16진수에서 10부터 15까지는 어떻게 표기할까요? 10은 a, 11은 b, …, 15는 f를 대입하여 사용합니다. 4bits씩 16진수로 변환 후 **0x**를 붙혀 뒤에 오는 문자들이 16진수임을 알려줍니다.

#### **16진수의 유용성**

ASCII 코드에 의해 “A, B, C”는 10진수로 65, 66, 67에 해당합니다. 컴퓨터는 10진수를 이해할 수 없으므로 2진수로 표현해보면  "01000001 01000010 01000011＂이 됩니다. 컴퓨터가 처리할 수 있어야 하기 때문에 어쩔 수 없지만 그 길이가 너무 긴 것을 알 수 있습니다.
하지만 16진수로 표현하면 2진수로 표현했을 때 보다 훨씬 간단해집니다. 또한 컴퓨터는 8개의 비트가 모인 바이트 단위로 정보를 표현합니다. **2개의 16진수는 1byte의 2진수로 변환**되기 때문에 정보를 표현하기 매우 유용합니다.
![image](https://cphinf.pstatic.net/mooc/20170807_161/1502072871106NqRxw_PNG/5.4_-02.png?type=w760)

#### **메모리 주소**

정수형 변수 n에 50이라는 값을 저장하고 출력한다고 생각해 봅시다.
이 n 이라는 값은 **int** 타입이므로, 아래 그림과 같이 우리 컴퓨터의 메모리 어딘가에 **4바이트** 만큼의 자리를 차지하며 저장되어 있을 것입니다.
![image](https://cs50.harvard.edu/x/2020/notes/4/n.png)  
C에서는 변수의 **메모리상 주소**를 받기 위해 **‘&’**이라는 연산자를 사용할 수 있습니다.

```c
#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%p\n", &n);
}
```

예를 들어, 위와 같은 코드를 실행하면 ‘0x7ffe00b3adbc’와 같은 값을 얻을 수 있고, 이는 변수 n의  **16진법**으로 표현된 메모리의 주소입니다.
반대로 **‘\*’**를 사용하면 그 메모리 주소에 있는 **실제 값**을 얻을 수 있습니다.

```c
#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%i\n", *&n);
}
```

위 코드는 먼저 **n의 주소**를 얻고, 또 다시 **그 주소에 해당하는 값**을 얻어와 출력한 것이므로 결국 ‘50’이라는 값이 출력되겠죠.

### 포인터

지난 강의에서 배웠던 ‘\*’ 연산자는 어떤 메모리 주소에 있는 값을 받아오게 해줍니다.

이 연산자를 이용해서 **포인터 역할을 하는 변수**를 선언할 수도 있습니다.

```c
#include <stdio.h>int main(void)
{
   int n = 50;
   int *p = &n;
   printf("%p\n", p);
   printf("%i\n", *p);
}
```

위 코드를 보면 정수형 변수 n에는 50이라는 값이 저장되어 있습니다.

그리고 **\*p**라는 **포인터 변수**에 &n 이라는 값, 즉 **변수 n의 주소**를 저장합니다.

int *p 에서 p앞의 *는 이 변수가 포인터라는 의미이고, int 는 이 포인터가 int 타입의 변수를 가리킨다는 의미입니다.

따라서 첫 번째 printf문과 같이 포인터 p의 값, 즉 변수 **n의 주소를 출력**하거나, 두 번째 printft문과 같이 포인터 **p가 가리키는 변수의 값**, 즉 변수 n의 값을 출력할 수도 있습니다.

만약 위 코드에서 int p = &n; 을 실행하였다면, &n은 주소인데 p에 저장하려고 한다고 컴파일러가 경고메세지를 보냄. 주소를 저장하기 위해서는 포인터를 표시하는 \*를 변수명 앞에 붙여줘야 한다.

\*는 포인터임을 가르키는 용도이기도 하고, 주소로 이동하라는 명령을 내리는 용도이기도 하다.

실제 컴퓨터 메모리에서 변수 p는 아래와 같이 저장될 수 있습니다.

![image](https://cs50.harvard.edu/x/2020/notes/4/p.png)

하지만 아래 그림과 같이 실제로 p의 값, 즉 n의 주소값을 생각하지 않고, 추상적으로 단지 **p가 n을 가리키고 있다는 것**만 생각해도 됩니다.

![image](https://cs50.harvard.edu/x/2020/notes/4/pointing.png)

이런 포인터를 기반으로 해서 앞으로 배울 다양한 데이터 구조를 정의하고 사용할 수 있습니다.

### 문자열

우리는 여태껏 문자열을 저장하기 위해 CS50 라이브러리에 포함된 string 자료형을 사용하였었습니다.

아래와 같이 s에 “EMMA”라는 값을 저장한다고 생각해 봅시다.

```c
string s = “EMMA”;
```

문자열은 결국 **문자의 배열**이고, s[0], s[1], s[2], … 와 같이 하나의 문자가 배열의 한 부분을 나타냅니다.

가장 마지막의 **\0**은 0으로 이루어진 바이트로, **문자열의 끝**을 표시하는 약속입니다.

![image](https://cs50.harvard.edu/x/2020/notes/4/s_array.png)

여기서 **변수 s**는 결국 이러한 **문자열을 가리키는 포인터**가 됩니다.

더 상세히는 문자열의 가장 첫번째 문자, 즉 주소 0x123에 있는 s[0]를 가리키게 됩니다.

![image](https://cs50.harvard.edu/x/2020/notes/4/s_pointer.png)

실제 CS50 라이브러리를 보면 string 자료형은 아래와 같이 정의되어 있습니다.

```c
typedef char *string
```

여기서 typedef는 새로운 자료형을, char \*은 문자에 대한 포인터를, string은 자료형의 이름을 의미합니다.

따라서 아래 두 코드는 동일하게 동작할 것입니다.

1. string 자료형을 이용하여 “EMMA” 출력

   ```c
   #include <cs50.h>
   #include <stdio.h>

   int main(void)
   {
       string s = "EMMA";
       printf("%s\n", s);
   }
   ```

2. char 포인터를 이용하여 “EMMA” 출력

   ```c
   #include <stdio.h>

   int main(void)
   {
       char *s = "EMMA";
       printf("%s\n", s);
   }
   ```

   2번 코드의 char \*s에서 s라는 변수는 문자에 대한 포인터가 되고, “EMMA”라는 문자열의 가장 첫 번째 값을 저장하기 때문이죠.

3. 만약 포인터 s의 첫번째 문자에 주소를 출력하려면 다음과 같이 출력할 수 있다.

   ```c
   #include <stdio.h>

   int main(void)
   {
       char *s = "EMMA";
       printf("%p\n", s);
   		printf("%p\n", &s[0]);
   }
   ```

   위와같이 2개의 주소를 출력하면 두개의 주소는 똑같다. 문자열의 맨 앞의 주소가 s에 저장되기 떄문에 s[0]과 s의 주소는 같다.

문자열이 들어간 포인터를 출력할때는 메모리를 참조하기 위한 \*를 쓰지 않아도 “EMMA”가 출력된다.

만약 \*s를 사용하려면 %s를 사용하여야 하고, 이는 E를 출력한다.

### 문자열 비교

```c
#include <stdio.h>

int main(void)
{
    char *s = "EMMA";
    printf("%p\n", s);
}
```

위 코드를 실행하면, s라는 포인터의 값, 즉 “EMMA”라는 문자열의 가장 첫 값인 “E”에 해당하는 **메모리 주소**를 출력하게 될 것입니다.

그렇다면 아래 코드들은 무엇을 출력할까요?

```c
printf("%p\n", &s[0]);
printf("%p\n", &s[1]);
printf("%p\n", &s[2]);
printf("%p\n", &s[3]);
```

s가 가리키는 곳을 시작으로 “EMMA”라는 문자열로 이루어진 문자들의 배열이 있으니, 각각

s라는 문자열의 첫 번째 문자에 해당하는 주소값,

s라는 문자열의 두 번째 문자에 해당하는 주소값,

s라는 문자열의 세 번째 문자에 해당하는 주소값,

s라는 문자열의 네 번째 문자에 해당하는 주소값을 출력하게 되겠죠.

이를 좀 더 자세히 들여다보면 &s[0]는 “E”의 주소값을, &s[1]은 “M”의 주소값을,  &s[2]은 “M”의 주소값을,  &s[3]은 “A”의 주소값을 의미합니다.

문자열은 첫번째 문자를 시작으로 메모리상에서 바로 옆에 저장되어 있습니다.

다시 말해, 가장 첫 번째 문자에 해당하는 **주소값을 하나씩 증가시키면** 바로 옆에 있는 문자의 값을 출력할 수 있는 것이죠.

따라서 아래 코드는 E M M A를 순서대로 출력할 것입니다.

```c
printf("%c\n", *s);
printf("%c\n", *(s+1));
printf("%c\n", *(s+2));
printf("%c\n", *(s+3));
```

문자열을 비교할 때도 아래 코드와 같이 문자열이 저장된 변수를 바로 비교하게 되면 그 변수가 저장되어 있는 **주소가 다르기 때문에** 다르다는 결과가 나올 것입니다.

정확한 비교를 위해서는 실제 문자열이 저장되어 있는 곳으로 이동하여, 각 문자를 하나하나씩 비교해야 되겠죠.

```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // 사용자로부터 s와 t 두 개의 문자열 입력받아 저장
    string s = get_string("s: ");
    string t = get_string("t: ");

    // 두 문자열을 비교 (각 문자들을 비교)
    if (s == t)
    {
        printf("Same\n");
    }
    else
    {
        printf("Different\n");
    }
}
```

### 문자열 복사

문자열을 복사하기 위해 아래 코드를 실행하면 어떻게 될까요?

```c
#include <cs50.h>
#include <ctype.h>
#include <stdio.h>

int main(void)
{
    string s = get_string("s: ");
    string t = s;

    t[0] = toupper(t[0]);

    printf("s: %s\n", s);
    printf("t: %s\n", t);
}
```

사용자에게 입력값을 받아 string s에 저장하고, string t를 s로 정의합니다.

그리고 t의 첫 번째 문자를 toupper 함수를 이용하여 대문자로 바꾼다면 s와 t는 각각 어떻게 출력 될까요?

입력값으로 “emma”를 주게 된다면, 단순한 예상과는 다르게 s와 t 모두 “Emma”라고 출력이 됩니다.

그 이유는  **s**라는 변수에는 “emma”라는 문자열이 아닌 그 문자열이 있는 **메모리의 주소가 저장**되기 때문이죠.

**string s** 는 **char \*s** 와 동일한 의미라는걸 떠올려보면 됩니다.

따라서 t도 s와 동일한 주소를 가리키고 있고, t를 통한 수정은 s에도 그대로 반영이 되게 되는 것입니다.

그렇다면 두 문자열을 실제로 메모리상에서 복사하려면 어떻게 해야 할까요?

아래 코드와 같이 **메모리 할당 함수**를 사용하면 됩니다

```c
#include <cs50.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    char *s = get_string("s: ");
    char *t = malloc(strlen(s) + 1);

    for (int i = 0, n = strlen(s); i < n + 1; i++)
    {
        t[i] = s[i];
    }

    t[0] = toupper(t[0]);

    printf("s: %s\n", s);
    printf("t: %s\n", t);
}
```

위의 코드와 다른 점은 **malloc**이라는 함수를 이용해서 t를 정의한다는 거죠.

malloc 이라는 함수는 정해진 크기 만큼 메모리를 할당하는 함수입니다.

즉 s 문자열의 길이에 **널 종단 문자(\0)**에 해당하는 **1**을 더한 만큼 메모리를 할당합니다.

그리고 루프를 돌면서 s 문자열 배열에 있는 문자 하나 하나를 t 배열에 복사해주면 됩니다.

이 코드를 컴파일 후 실행시키고 입력값으로 “emma”를 주면 우리가 예상한 대로 s는 “emma”가, t는 “Emma”가 출력되게 됩니다.

성공적으로 복사가 된 것을 확인할 수 있습니다.

이 코드의 루프문에서 주의해야 할 점은 반복문의 조건이 n+1이여야한다는 것입니다. 왜냐하면 문자열의 메모리는 “EMMA\0”로 종단문자까지 총5글자이고, 포인터 t에도 종단문자까지 루프를 돌아서 복사해야하기 떄문에 n+1로 조건을 설정해야 합니다.

### 메모리 할당과 해제

malloc 함수를 이용하여 메모리를 할당한 후에는 **free**라는 함수를 이용하여 메모리를 해제해줘야 합니다.

그렇지 않은 경우 메모리에 저장한 값은 **쓰레기 값**으로 남게 되어 메모리 용량의 낭비가 발생하게 되기 때문이죠.

이러한 현상을 **‘메모리 누수’**라고 일컫습니다.

**valgrind** 라는 프로그램을 사용하면 우리가 작성한 코드에서 메모리와 관련된 문제가 있는지를 쉽게 확인할 수 있습니다.

```
help50 valgrind ./filename
```

와 같은 명령어를 사용하면 filename 파일에 대한 valgrind의 검사 내용을 쉽게 확인할 수 있습니다.

아래와 같은 코드가 있다고 생각해봅시다.

```c
#include <stdlib.h>
void f(void)
{
    int *x = malloc(10 * sizeof(int));
    x[10] = 0;
}

int main(void)
{
    f();
    return 0;
}
```

f 함수를 살펴보면 먼저 포인터 x에는 int형의 사이즈(4바이트)에 10배에 해당하는 크기의 메모리, 즉 40바이트를 할당합니다.

그리고 x의 10번째 값으로 0을 할당합니다.

그리고 main 함수에서 f를 실행하게 되는데, 이 코드를 **valgrind** 로 검사해보면 버퍼 오버플로우와 메모리 누수 두 가지 에러를 확인할 수 있습니다.

먼저 **버퍼 오버플로우**는 x[10] = 0; 코드로 인해 발생합니다.

우리는 10개의 int형의 배열을 만들었는데 배열의 인덱스가 0부터 시작한다는 점을 감안하면 인덱스 10은 11번째 인덱스에 접근하겠다는 의미이고, 이는 정의되지 않은 것이기 때문에 버퍼 오버플로우가 발생하는 것이죠.

따라서 이 오류는 0에서 9 사이의 인덱스를 사용하면 해결할 수 있습니다.

또한 **메모리 누수**는 x라는 포인터를 통해 할당한 메모리를 해제하기 위해 free(x) 라는 코드를 추가해줌으로써 해결할 수 있습니다.

결과적으로 아래와 같이 작성되어야 합니다.

```c
#include <stdlib.h>
void f(void)
{
    int *x = malloc(10 * sizeof(int));
    x[9] = 0;    // x배열은 malloc을 이용하여 40byte로 할당되었고, int형은 1개의 인덱스에 4byte를 사용하므로, 총 10개의 인덱스가 있음. 따라서 0~9까지의 배열순서를 가지고 있어서 10은 사용하지 못함.
		free(x)      // x배열의 메모리를 해제. 총 40byte의 메모리를 해제하여 메모리를 절약하는 용도.
}

int main(void)
{
    f();
    return 0;
}
```

### 메모리 교환, 스택, 힙

아래와 같은 코드가 있습니다. 함수 **swap**은 정수 a와 b를 입력받아 그 값을 바꾸는 일을 수행합니다.

main 함수에서는 x에 1, y에 2를 입력하고 swap 함수를 통해 그 두 값을 바꾸려고 하고 있습니다.

과연 의도대로 잘 바뀌어서 출력이 될까요?

```c
#include <stdio.h>

void swap(int a, int b);

int main(void)
{
    int x = 1;
    int y = 2;

    printf("x is %i, y is %i\n", x, y);
    swap(x, y);
    printf("x is %i, y is %i\n", x, y);
}

void swap(int a, int b)
{
    int tmp = a;
    a = b;
    b = tmp;
}
```

위 코드를 컴파일하고 출력해보면 우리 의도와는 다르게 swap 함수를 거친 후에도 x와 y의 값이 바뀌지 않은채 그대로 출력됨을 알 수 있습니다.

사실 swap 함수는 교환 작업을 제대로 수행하고 있는데요, 문제는 교환하는 대상이 x, y 그 자체가 아닌 함수 내에서 새롭게 정의된 a, b라는 것이었습니다.

a와 b는 각각 x와 y의 **값을 복제**하여 가지게 됩니다. **서로 다른 메모리 주소에 저장**되는 것이죠.

아래 그림에서와 같이 메모리 안에는 데이터 저장되는 구역이 나뉘어져 있습니다.

머신 코드 영역에는 우리 프로그램이 실행될 때 그 프로그램이 컴파일된 바이너리가 저장됩니다.

글로벌 영역에는 프로그램 안에서 저장된 전역 변수가 저장됩니다.

**힙** 영역에는 malloc으로 할당된 메모리의 데이터가 저장됩니다. 그리고 **스택**에는 프로그램 내의 함수와 관련된 것들이 저장됩니다.

![image](https://cs50.harvard.edu/x/2020/notes/4/memory_layout.png)

이를 바탕으로 다시 생각해보면, 위의 코드에서 a, b, x, y, tmp 모두 **스택 영역**에 저장되지만 a와 x, b와 y는 그 안에서도 서로 다른 위치에 저장된 변수입니다.

따라서 a와 b를 바꾸는 것은 x와 y를 바꾸는 것에 아무런 영향도 미치지 않는 것이죠.

따라서 아래 그림 및 코드와 같이 a와 b를 각각 **x와 y를 가리키는 포인터로 지정**함으로써 이 문제를 쉽게 해결할 수 있습니다.

![image](https://cs50.harvard.edu/x/2020/notes/4/pointers.png)

```c
#include <stdio.h>

void swap(int *a, int *b);

int main(void)
{
    int x = 1;
    int y = 2;

    printf("x is %i, y is %i\n", x, y);
    swap(&x, &y);
    printf("x is %i, y is %i\n", x, y);
}

void swap(int *a, int *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
```

### 파일 쓰기

지난 강의에서 아래 그림과 같은 **메모리 구조**를 간략하게 배웠었습니다.

다시 복습하면, **머신 코드 영역**에는 우리 프로그램이 실행될 때 그 프로그램이 컴파일된 바이너리가 저장됩니다.

**글로벌 영역**에는 프로그램 안에서 저장된 전역 변수가 저장됩니다.

**힙 영역**에는 malloc으로 할당된 메모리의 데이터가 저장됩니다. 그리고 **스택**에는 프로그램 내의 함수와 관련된 것들이 저장됩니다.

![image](https://cs50.harvard.edu/x/2020/notes/4/memory_layout.png)

힙 영역에서는 **malloc 에 의해 메모리가 더 할당될수록**, 점점 사용하는 메모리의 범위가 아래로 늘어납니다.

마찬가지로 스택 영역에서도 **함수가 더 많이 호출 될수록** 사용하는 메모리의 범위가 점점 위로 늘어납니다.

이렇게 점점 늘어나다 보면 제한된 메모리 용량 하에서는 기존의 값을 침범하는 상황도 발생할 것입니다.

이를 **힙 오버플로우** 또는 **스택 오버플로우**라고 일컫습니다.

#### **사용자에게 입력 받기**

스택은 우리가 여태껏 많이 써왔던 get_int나 get_string 과 같은 함수에서도 사용됩니다.

만약 이런 함수들을 직접 구현한다면 아래와 같은 코드가 될 것입니다.

**[get_int 코드]**

```c
#include <stdio.h>

int main(void)
{
    int x;
    printf("x: ");
    scanf("%i", &x);
    printf("x: %i\n", x);
}
```

**[get_string 코드]**

```c
#include <stdio.h>

int main(void)
{
    char s[5];
    printf("s: ");
    scanf("%s", s);
    printf("s: %s\n", s);
}
```

위 코드들에서 **scanf**라는 함수는 사용자로부터 형식 지정자에 해당되는 값을 입력받아 저장하는 함수입니다.

get_int 코드에서 int x를 정의한 후에 scanf에 s가 아닌 **&s**로 그 주소를 입력해주는 부분을 유의하기 바랍니다.

scanf 함수의 변수가 실제로 스택 영역 안에 s가 저장된 주소로 찾아가서 사용자가 입력한 값을 저장하도록 하기 위함입니다.

반면 get_string 코드에서는 scanf에 그대로 s를 입력해줬습니다.

그 이유는 s를 크기가 5인 문자열, 즉 크기가 5인 char 자료형의 배열로 정의하였기 때문입니다.

**clang** 컴파일러는 문자 배열의 이름을 포인터처럼 다룹니다. 즉 scanf에 s라는 배열의 첫 바이트 주소를 넘겨주는 것이죠.

#### **파일 쓰기**

이제 사용자로부터 입력을 받아 파일에 저장하는 프로그램도 작성할 수 있습니다

```c
#include <cs50.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    FILE *file = fopen("phonebook.csv", "a");
    char *name = get_string("Name: ");
    char *number = get_string("Number: ");
    fprintf(file, "%s,%s\n", name, number);
    fclose(file);
}
```

**fopen**이라는 함수를 이용하면 파일을 FILE이라는 자료형으로 불러올 수 있습니다.
fopen 함수의 첫번째 인자는 파일의 이름, 두번째 인자는 모드로 r은 읽기, w는 쓰기, a는 덧붙이기를 의미합니다.
사용자에게 name과 number라는 문자열을 입력 받고, 이를 **fprintf** 함수를 이용하여 printf에서처럼 파일에 직접 내용을 출력할 수 있습니다.
작업이 끝난 후에는 **fclose**함수로 파일에 대한 작업을 종료해줘야 합니다.
이 작업 후에는 phonebook.csv라는 파일이 없을 경우에는 해당 파일이 생성되고, 파일이 있다면 name과 number이 한줄씩 추가되어 나타납니다.

### 파일 읽기

이전 강의에서 파일에 쓰는 프로그램을 작성 했다면,  이번 강의에서는 파일의 내용을 읽어서 파일의 형식이 JPEG 이미지인지를 검사하는 프로그램을 작성해보겠습니다.

```c
#include <stdio.h>

int main(int argc, char *argv[])
{
    if (argc != 2)
    {
        return 1;
    }

    FILE *file = fopen(argv[1], "r");

    if (file == NULL)
    {
        return 1;
    }

   unsigned char bytes[3];
    fread(bytes, 3, 1, file);

    if (bytes[0] == 0xff && bytes[1] == 0xd8 && bytes[2] == 0xff)
    {
        printf("Maybe\n");
    }
    else
    {
        printf("No\n");
    }
    fclose(file);
}
```

위 코드에서 main 함수를 보면 사용자로부터 입력을 받는 것을 알 수 있습니다.

여기서는 **파일의 이름**을 입력으로 받을 예정입니다.

만약 argc가 2가 아니라면, 파일명이 입력되지 않았거나 파일명 외의 다른 인자가 입력되었기 때문에 1(오류)을 리턴하고 프로그램을 종료합니다.

만약 argc가 2라면 프로그램이 그대로 진행됩니다.

입력받은 파일명(argv[1])을 **‘읽기(r)’** 모드로 불러옵니다.

만약 파일이 제대로 열리지 않으면 fopen 함수는 NULL을 리턴하기 때문에 이를 검사해서 file을 제대로 쓸 수 있는지를 검사하고, 아니라면 역시 1(오류)를 리턴하고 프로그램을 종료합니다.

만약 파일이 잘 열렸다면, 프로그램이 계속 진행됩니다.

그 후 크기가 3인 문자 배열을 만들고, fread 함수를 이용해서 파일에서 첫 3바이트를 읽어옵니다.

fread 함수의 각 인자는 (배열, 읽을 바이트 수, 읽을 횟수, 읽을 파일)을 의미합니다.

그리고 마지막으로 읽어들인 각 바이트가 각각 0xFF, 0xD8, 0xFF 인지를 확인합니다.

이는 **JPEG 형식의 파일을 정의할 때 만든 약속**으로, JPEG 파일의 시작점에 꼭 포함되어 있어야 합니다.

따라서 이를 검사하면 JPEG 파일인지를 확인할 수 있습니다.

---

# 자료구조

💡 추상자료형이라는 것을 배운다.
연결리스트, 트리구조, 해시 테이블, 트라이에 대해 배우게 된다.

이러한 것들을 이용해서 큐, 스택, 딕셔너리를 만들어 사용하게 된다.

### malloc과 포인터 복습

아래와 같은 main 함수 코드가 있습니다. 여기서 문제가 될 만한 지점을 발견할 수 있나요?

```c
int main(void)
{
    int *x;
    int *y;

    x = malloc(sizeof(int));

    *x = 42;
    *y = 13;
}
```

main 함수 안의 첫 두 줄에서는 **포인터 x와 y**를 선언합니다.

그리고 x에는 **malloc** 함수를 이용해서 int 자료형 크기에 해당하는 메모리를 할당합니다.

그 다음에는 x와 y 포인터가 가리키는 지점에 각각 42와 13을 저장합니다.

여기서 문제가 될 만한 부분은 \*y = 13 입니다. y는 포인터로만 선언되었을 뿐이지, 어디를 가리킬지에 대해서는 아직 정의가 되지 않았습니다.

따라서 **초기화 되지 않은 \*y**는 프로그램 어딘가를 임의로 가리키고 있을 수도 있습니다.

따라서 그 곳에 13이라는 값을 저장하는 것이 오류를 발생시킬 수도 있는 것이죠.

아래 코드와 같이 **y = x;** 라는 코드를 더해주면,  y는 x가 가리키는 곳과 동일한 곳을 가리키게 됩니다.

따라서 \*y = 13; 으로 저장하면  x가 가리키는 곳에도 동일하게 13으로 저장될 것입니다.

```c
y = x;

*y = 13;
```

### 배열의 크기 조정하기

일정한 크기의 배열이 주어졌을 때, 그 크기를 키우려면 어떻게 해야 할까요?

단순하게 현재 배열이 저장되어 있는 메모리 위치의 바로 옆에 일정 크기의 메모리를 더 덧붙이면 되겠지만, 실제로는 다른 데이터가 저장되어 있을 확률이 높습니다.

따라서 안전하게 **새로운 공간에 큰 크기의 메모리를 다시 할당**하고 기존 배열의 값들을 하나씩 옮겨줘야 합니다.

따라서 이런 작업은 **O(n)**, 즉 배열의 크기 n만큼의 실행 시간이 소요될 것입니다.

이 과정을 아래 코드와 같이 나타낼 수 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    //int 자료형 3개로 이루어진 list 라는 포인터를 선언하고 메모리 할당
    int *list = malloc(3 * sizeof(int));

    // 포인터가 잘 선언되었는지 확인
    if (list == NULL)
    {
        return 1;
    }

    // list 배열의 각 인덱스에 값 저장
    list[0] = 1;
    list[1] = 2;
    list[2] = 3;

    //int 자료형 4개 크기의 tmp 라는 포인터를 선언하고 메모리 할당
    int *tmp = malloc(4 * sizeof(int));

    if (tmp == NULL)
    {
        return 1;
    }

    // list의 값을 tmp로 복사
    for (int i = 0; i < 3; i++)
    {
        tmp[i] = list[i];
    }

    // tmp배열의 네 번째 값도 저장
    tmp[3] = 4;

    // list의 메모리를 초기화
    free(list);

    // list가 tmp와 같은 곳을 가리키도록 지정
    list = tmp;

    // 새로운 배열 list의 값 확인
    for (int i = 0; i < 4; i++)
    {
        printf("%i\n", list[i]);
    }

    // list의 메모리 초기화
    free(list);
}
```

위와 동일한 작업을 **realloc** 이라는 함수를 이용해서 수행할 수도 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int *list = malloc(3 * sizeof(int));
    if (list == NULL)
    {
        return 1;
    }

    list[0] = 1;
    list[1] = 2;
    list[2] = 3;

    // tmp 포인터에 메모리를 할당하고 list의 값 복사
    **int *tmp = realloc(list, 4 * sizeof(int));**
    if (tmp == NULL)
    {
        return 1;
    }

    // list가 tmp와 같은 곳을 가리키도록 지정
    list = tmp;

    // 새로운 list의 네 번째 값 저장
    list[3] = 4;

    // list의 값 확인
    for (int i = 0; i < 4; i++)
    {
        printf("%i\n", list[i]);
    }

    //list 의 메모리 초기화
    free(list);
}
```

### 연결 리스트: 도입

**데이터 구조**는 우리가 컴퓨터 메모리를 더 효율적으로 관리하기 위해 새로 정의하는 구조체입니다.

일종의 메모리 레이아웃, 또는 지도라고 생각할 수 있습니다.

이번 강의에서는 데이터 구조중 하나인 **연결 리스트**에 대해 알아보겠습니다.

**배열**에서는 각 인덱스의 값이 메모리상에서 연이어 저장되어 있습니다.

하지만 꼭 그럴 필요가 있을까요? 각 값이 메모리상의 여러 군데 나뉘어져 있다고 하더라도 바로 다음 값의 **메모리 주소**만 기억하고 있다면 여전히 값을 연이어서 읽어들일 수 있습니다.

이를 **‘연결 리스트’**라고 합니다. 아래 그림과 같이 크기가 3인 연결 리스트는 각 인덱스의 메모리 주소에서 **자신의 값**과 함께 **바로 다음 값의 주소(포인터)**를 저장합니다.

![image](https://cs50.harvard.edu/x/2020/notes/5/linked_list_with_addresses.png)

연결 리스트의 가장 첫 번째 값인 1은 2의 메모리 주소를, 2는 3의 메모리 주소를 함께 저장하고 있습니다.

3은 다음 값이 없기 때문에 NULL (\0, 즉 0으로 채워진 값을 의미합니다)을 다음 값의 주소로 저장합니다.

연결 리스트는 아래 코드와 같이 간단한 구조체로 정의할 수 있습니다.

```c
typedef struct node
{
    int number;
    node *next;
}
node;
```

node 라는 이름의 구조체는 number 와 \*next  두 개의 필드가 함께 정의되어 있습니다.

number는 **각 node가 가지는 값**, \*next 는 **다음 node를 가리키는 포인터**가 됩니다.

여기서 typedef struct 대신에 typedef struct node 라고 ‘node’를 함께 명시해 주는 것은, 구조체 안에서 node를 사용하기 위함입니다.

### 연결 리스트: 코딩

앞서 정의한 구조체를 활용해서 실제로 연결 리스트를 구현해보도록 하겠습니다.

아래 코드의 내용과 각 주석을 따라가 보세요.

```c
#include <stdio.h>
#include <stdlib.h>//연결 리스트의 기본 단위가 되는 node 구조체를 정의합니다.

typedef struct node
{
    //node 안에서 정수형 값이 저장되는 변수를 name으로 지정합니다.
    int number;

    //다음 node의 주소를 가리키는 포인터를  *next로 지정합니다.
    struct node *next;
}
node;

int main(void)
{
    // list라는 이름의 node 포인터를 정의합니다. 연결 리스트의 가장 첫 번째 node를 가리킬 것입니다.
    // 이 포인터는 현재 아무 것도 가리키고 있지 않기 때문에 NULL 로 초기화합니다.
    node *list = NULL;

    // 새로운 node를 위해 메모리를 할당하고 포인터 *n으로 가리킵니다.
    node *n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }

    // n의 number 필드에 1의 값을 저장합니다. “n->number”는 “(*n).number”와 동일한 의미입니다.
    // 즉, n이 가리키는 node의 number 필드를 의미하는 것입니다.
    // 간단하게 화살표 표시 ‘->’로 쓸 수 있습니다. n의 number의 값을 1로 저장합니다.
    n->number = 1;

    // n 다음에 정의된 node가 없으므로 NULL로 초기화합니다.
    n->next = NULL;

    // 이제 첫번째 node를 정의했기 떄문에 list 포인터를 n 포인터로 바꿔 줍니다.
    list = n;

    // 이제 list에 다른 node를 더 연결하기 위해 n에 새로운 메모리를 다시 할당합니다.
    n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }

    // n의 number와 next의 값을 각각 저장합니다.
    n->number = 2;
    n->next = NULL;

    // list가 가리키는 것은 첫 번째 node입니다.
    //이 node의 다음 node를 n 포인터로 지정합니다.
    list->next = n;

    // 다시 한 번 n 포인터에 새로운 메모리를 할당하고 number과 next의 값을 저장합니다.
    n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }

    n->number = 3;
    n->next = NULL;

    // 현재 list는 첫번째 node를 가리키고, 이는 두번째 node와 연결되어 있습니다.
    // 따라서 세 번째 node를 더 연결하기 위해 첫 번째 node (list)의
    // 다음 node(list->next)의 다음 node(list->next->next)를 n 포인터로 지정합니다.
    list->next->next = n;

    // 이제 list에 연결된 node를 처음부터 방문하면서 각 number 값을 출력합니다.
    // 마지막 node의 next에는 NULL이 저장되어 있을 것이기 때문에 이 것이 for 루프의 종료 조건이 됩니다.
    for (node *tmp = list; tmp != NULL; tmp = tmp->next)
    {
        printf("%i\n", tmp->number);
    }

    // 메모리를 해제해주기 위해 list에 연결된 node들을 처음부터 방문하면서 free 해줍니다.
    while (list != NULL)
    {
        node *tmp = list->next;
        free(list);
        list = tmp;
    }
}
```

### 연결 리스트: 시연

연결 리스트의 원리를 학생들의 시연을 통해 살펴보았습니다.

배열과 비교해서 **연결 리스트**는 새로운 값을 추가할 때 다시 메모리를 할당하지 않아도 된다는 장점이 있습니다.

하지만 이런 유동적인 구조는 그 대가가 따릅니다. 구조가 정적인 배열과 달리 연결 리스트에서는 임의 접근이 불가능합니다.

연결 리스트에 값을 추가하거나 검색하는 경우를 생각해 봅시다.

이를 위해서는 해당하는 위치까지 연결 리스트의 각 node들을 따라 이동해야 합니다.

따라서 연결 리스트의 크기가 n 일때 그 실행 시간은 **O(n)**이 됩니다.

배열의 경우 임의 접근이 가능하기 때문에 (정렬 되어 있는 경우) 이진 검색을 이용하면 **O(log n)**의 실행 시간이 소요 되는 것에 비해서 다소 불리합니다.

이처럼 여러 데이터 구조는 각각 장단점이 존재합니다.

프로그래밍을 할 때 목적에 부합하는 가장 효율적인 데이터 구조를 고민해서 사용하는 것이 중요합니다.

### 연결 리스트: 트리

트리는 연결리스트를 기반으로 한 새로운 데이터 구조입니다.

연결리스트에서의 각 노드 (연결 리스트 내의 한 요소를 지칭)들의 연결이 1차원적으로 구성되어 있다면, 트리에서의 노드들의 연결은 2차원적으로 구성되어 있다고 볼 수 있습니다.

각 노드는 일정한 층에 속하고, 다음 층의 노드들을 가리키는 포인터를 가지게 됩니다.

아래 그림은 트리의 한 예입니다. 나무가 거꾸로 뒤집혀 있는 형태를 생각하면 됩니다.

가장 높은 층에서 트리가 시작되는 노드를 ‘**루트**’라고 합니다. 루트 노드는 다음 층의 노드들을 가리키고 있고, 이를 ‘**자식 노드**’라고 합니다.

![image](https://cs50.harvard.edu/x/2020/notes/5/binary_search_tree.png)

위 그림에 묘사된 트리는 구체적으로 ‘**이진 검색 트리**’ 입니다.

각 노드가 구성되어 있는 구조를 살펴보면 일정한 규칙을 알 수 있습니다.

먼저 하나의 노드는 두 개의 자식 노드를 가집니다.

또 왼쪽 자식 노드는 자신의 값 보다 작고, 오른쪽 자식 노드는 자신의 값보다 큽니다.

따라서 이런 트리 구조는 이진 검색을 수행하는데 유리합니다.

아래 코드에서는 이진 검색 트리의 노드 구조체와 “50”을 재귀적으로 검색하는 **이진 검색 함수**를 구현하였습니다.

```c
//이진 검색 트리의 노드 구조체
typedef struct node
{
    // 노드의 값
    int number;

    // 왼쪽 자식 노드
    struct node *left;

   // 오른쪽 자식 노드
    struct node *right;
} node;

// 이진 검색 함수 (*tree는 이진 검색 트리를 가리키는 포인터)
bool search(node *tree)
{
    // 트리가 비어있는 경우 ‘false’를 반환하고 함수 종료
    if (tree == NULL)
    {
        return false;
    }
    // 현재 노드의 값이 50보다 크면 왼쪽 노드 검색
    else if (50 < tree->number)
    {
        return search(tree->left);
    }
    // 현재 노드의 값이 50보다 작으면 오른쪽 노드 검색
    else if (50 > tree->number)
    {
        return search(tree->right);
    }
    // 위 모든 조건이 만족하지 않으면 노드의 값이 50이므로 ‘true’ 반환
    else {
        return true;
    }
}
```

이진 검색 트리를 활용하였을 때 검색 실행 시간과 노드 삽입 시간은 모두 **O(log n)** 입니다.

따라서 이 트리구조는 연결리스트보다 공간을 더 많이 사용하여 시간을 단축시킨 방법입니다.

### 해시 테이블

해시 테이블은 **‘연결 리스트의 배열’**입니다. 여러 값들을 몇 개의 바구니에 나눠 담는 상황을 생각해 봅시다.

각 값들은 **‘해시 함수’**라는 맞춤형 함수를 통해서 어떤 바구니에 담기는 지가 결정 됩니다.

각 바구니에 담기는 값들은 그 바구니에서 새롭게 정의되는 연결 리스트로 이어집니다.

이와 같이 연결 리스트가 담긴 바구니가 여러개 있는 것이 ‘연결 리스트의 배열’, 즉 ‘해시 테이블’이 됩니다.

쉬운 예로 아래 그림과 같이 사람의 이름이 해시 테이블에 저장되며, 해시 함수는 **‘이름의 가장 첫 글자’**인 경우를 생각해 보겠습니다.

그 경우 알파벳 개수에 해당하는 총 26개의 포인터들이 있을 수 있으며, 각 포인터는 그 알파벳을 시작으로 하는 이름들을 저장하는 연결 리스트를 가리키게 됩니다.

![image](https://cs50.harvard.edu/x/2020/notes/5/hash_table.png)

만약 해시 함수가 이상적이라면, 각 바구니에는 단 하나의 값들만 담기게 될 것입니다.

따라서 검색 시간은 **O(1)**이 됩니다.

하지만 그렇지 않은 경우, 최악의 상황에는 단 하나의 바구니에 모든 값들이 담겨서 **O(n)**이 될 수도 있습니다.

일반적으로는 최대한 많은 바구니를 만드는 해시 함수를 사용하기 때문에 거의 O(1)에 가깝다고 볼 수 있습니다.

### 트라이

**‘트라이’**는 기본적으로 ‘트리’ 형태의 자료 구조입니다.

특이한 점은 **각 노드가 ‘배열’**로 이루어져있다는 것입니다.

예를 들어 영어 알파벳으로 이루어진 문자열 값을 저장한다고 한다면 이 노드는 a부터 z까지의 값을 가지는 배열이 됩니다.

그리고 배열의 각 요소, 즉 알파벳은 다음 층의 노드(a-z 배열)를 가리킵니다.

아래 그림과 같이 Hermione, Harry, Hagrid 세 문자열을 트라이에 저장해보겠습니다.

루트 노드를 시작으로 각 화살표가 가리키는 알파벳을 따라가면서 노드를 이어주면 됩니다.

![image](https://cs50.harvard.edu/x/2020/notes/5/trie.png)

위와 같은 트라이에서 값을 검색하는데 걸리는 시간은  **‘문자열의 길이’**에 의해 한정됩니다.

단순히 문자열의 각 문자를 보며 트리를 탐색해나가기만 하면 되니까요.

일반적인 영어 이름의 길이를 **n**이라고 했을 때, 검색 시간은 **O(n)**이 되지만, 대부분의 이름은 그리 크지 않은 **상수값**(예, 20자 이내)이기 때문에 **O(1)**이나 마찬가지라고 볼 수 있습니다.

이 트라이는 탐색이나 다른 작업을 하는 데에 시간을 아주 많이 줄인 대신에 공간을 많이 차지한다. 위 그림의 예시만 보더라도 엄청난 메모리를 사용하여 3개의 이름만을 저장하였기 때문이다.

따라서 trade off적이다.

### 스택, 큐, 딕셔너리

우리가 여태껏 배운 배열, 연결 리스트, 해시 테이블, 트라이 외에도 많은 자료 구조들이 있습니다.

또는 위의 자료 구조를 기반으로 해서 문제를 해결하는데 적합한 새로운 자료 구조를 만들 수도 있습니다.

아래와 같이 세 가지의 대표적인 자료 구조를 간단하게 알아보겠습니다.

#### **큐**

큐는 메모리 구조에서 살펴봤듯이 값이 아래로 쌓이는 구조입니다.

값을 넣고 뺄 때 **‘선입 선출’** 또는 **‘FIFO’**라는 방식을 따르게 됩니다. 가장 먼저 들어온 값이 가장 먼저 나가는 것이죠.

은행에서 줄을 설 때 가장 먼저 줄을 선 사람이 가장 먼저 업무를 처리하게 되는 것과 동일합니다.

**배열**이나 **연결 리스트**를 통해 구현 가능합니다.

큐에 들어가는 것을 enqueue라 하고, 큐에서 나오는 것을 dequeue라고 한다.

#### **스택**

반면 스택은 역시 메모리 구조에서 살펴봤듯이 값이 위로 쌓이는 구조입니다.

따라서 값을 넣고 뺄 때 **‘후입 선출’** 또는 **‘LIFO’**라는 방식을 따르게 됩니다. 가장 나중에 들어온 값이 가장 먼저 나가는 것이죠.

뷔페에서 접시를 쌓아 뒀을 때 사람들이 가장 위에 있는(즉, 가장 나중에 쌓인) 접시를 가장 먼저 들고 가는 것과 동일합니다.

역시 **배열**이나 **연결 리스트**를 통해 구현 가능합니다.

스택에 들어가는 것을 push라 하고, 스택에서 나오는 것을 pop이라고 한다.

#### **딕셔너리**

딕셔너리는 **‘키’**와 **‘값’**이라는 요소로 이루어져 있습니다.

‘키’에 해당하는 ‘값’을 저장하고 읽어오는 것이죠. 마치 대학교에서 ‘학번’에 따라서 ‘학생’이 결정되는 것과 동일합니다.

일반적인 의미에서 **‘해시 테이블’**과 동일한 개념이라고도 볼 수 있습니다.

역시 ‘키’를 어떻게 정의할 것인지가 중요합니다.
