<!DOCTYPE html>
<html>
<head>
    <title> Docker란? 도커 총 정리 및 실습하기 |  Jiwon's Blog</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="author" content="Jiwon Ryu">
    <meta name="description" content="A blog and a portfolio">
    <link rel="shortcut icon" type="image/png" href="/image/개발자이모티콘2.png">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Crimson+Text">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.4.2/css/bulma.min.css">
    <link rel="stylesheet" href="/css/styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@600&display=swap" rel="stylesheet">
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-95PRM2RDE8"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-95PRM2RDE8');
    </script>
</head>

<body>
    <nav class="nav">
    <div class="container">
        <div class="nav-left">
            <a id="home" class="nav-item" href="/">
                <span class="icon">
                    <i class="fa fa-home"></i>
                </span>
            </a>
            
            <a id="project" class="nav-item " href="/project/">
                <span>Project</span>
            </a>
            
            <a id="category" class="nav-item " href="/category/">
                <span>Blog</span>
            </a>
            
        </div>

        <div class="nav-center">
            
        </div>

        <!--
        <span class="nav-toggle">
        <span></span>
        <span></span>
        <span></span>
        </span>

        
        <div class="nav-right nav-menu">
            
        </div>
        -->

</nav>
    <div class='content'>
        <section class="section">
  <div class="container">
    <div class="heading has-text-centered">
      <p class="title is-2">Docker란? 도커 총 정리 및 실습하기</p>
      <p class="subtitle is-6">
        <span class="tag is-white"><small>April 06, 2024</small></span>
      </p>
    </div>
    <br />
    <div class="columns is-multiline">
      <div class="column is-half is-offset-one-quarter">
        <div class="content"><p>Docker에 대한 포스팅</p>

<h2 id="1-docker의-사용-이유">1. Docker의 사용 이유</h2>

<ul>
  <li>애플리케이션(자바+스크링, 노드+리엑트 등)을 이미지화 하여 관리하면 개발환경 세팅, 서버 세팅 및 확장하는데에 편리함을 제공한다.</li>
  <li>이미지를 다운받아 실행하면 이미지화시킨 애플리케이션이 그대로 실행된다.</li>
  <li>각 컨테이너에서의 애플리케이션간의 독립성을 가진다. 같은 환경안에 실행되어도 각각의 컨테이너들은 독립된 공간을 보장받아 충돌이 발생하지 않는다.</li>
  <li>하나의 컴퓨터에서 여러 애플리케이션을 구동해야할 때에도 자주 사용된다.</li>
  <li>VM을 사용했을때에도 독립적인 공간에서 실행이 가능하지만 OS가 함께 설치되어 돌아가기 때문에 매우 무거워지므로 컨테이너를 활용했을때가 더욱 효율적이다.</li>
</ul>

<hr />

<h2 id="2-docker의-역할">2. Docker의 역할</h2>

<ul>
  <li>Docker는 애플리케이션을 이미지화를 시켜주는 기능을 제공한다.</li>
  <li>이미지를 실행시키면 컨테이너에 담겨 이미지가 실행된다. 이 때 이미지는 <code class="language-plaintext highlighter-rouge">컨테이너 엔진</code>위에서 실행되는데, Docker가 이 컨테이너 엔진 역할을 한다.</li>
  <li>도커는 기본적으로 리눅스OS에서 실행된다. 리눅스에서 도커를 실행할 때에는 컨테이너 엔진이 바로 실행되지만, 윈도우나 Mac에서 도커 프로그램을 실행할 경우 도커 프로그램은 리눅스OS를 자동으로 실행하고, 리눅스안에서 컨테이너 엔진이 실행되며, 그 위에 컨테이너들이 실행되게 되는 것이다.</li>
</ul>

<hr />

<h2 id="3-docker-설치">3. Docker 설치</h2>

<h4 id="3-1-window에-설치">3-1. Window에 설치</h4>

<ul>
  <li>도커 홈페이지 들어가서 Window 용으로 설치.</li>
</ul>

<h4 id="3-2-linux에-설치">3-2. Linux에 설치</h4>

<p>Docker를 Linux 운영체제에 설치하는 방법을 다룬 내용이다. 공식문서와 설치방법이 완전히 같으며, 부가설명을 추가하였다.<br />
<a href="https://docs.docker.com/engine/install/ubuntu/">도커 설치 공식문서</a> 를 참고하였다.<br />
다 귀찮다면 그냥 아래 코드 따라치면 된다…</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">sudo apt-get update</code></strong>
    <ul>
      <li>APT(Advanced Package Tool) 패키지 관리자의 패키지 목록을 최신 상태로 업데이트하는 명령어</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">sudo apt-get install ca-certificates curl</code></strong>
    <ul>
      <li>특정 패키지들을 설치하는 명령어</li>
      <li>ca-certificates : SSL/TLS 연결에 필요한 인증서를 관리하는 데 사용됨</li>
      <li>curl : 커맨드 라인에서 URL을 통해 데이터를 전송하거나 받을 수 있는 도구</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">sudo install -m 0755 -d /etc/apt/keyrings</code></strong>
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">/etc/apt/keyrings</code></strong> 디렉토리를 생성하는 데 사용됨.</li>
      <li>이 디렉토리는 APT(Advanced Package Tool) 패키지 관리자가 패키지 서명 키를 보관하는 데 사용</li>
      <li><strong><code class="language-plaintext highlighter-rouge">-m 0755</code></strong>: 생성된 디렉토리의 퍼미션을 지정합니다. 여기서 <strong><code class="language-plaintext highlighter-rouge">0755</code></strong>는 소유자에게 읽기, 쓰기, 실행 권한을 부여하고, 다른 사용자들에게는 실행 권한을 부여하는 것을 의미합니다.</li>
      <li><strong><code class="language-plaintext highlighter-rouge">-d</code></strong>: 디렉토리를 생성하는 데 사용됩니다. 파일이 아닌 디렉토리를 생성하는 것을 지정하는 옵션입니다.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc</code></strong>
    <ul>
      <li>Docker의 공식 GPG 키를 <strong><code class="language-plaintext highlighter-rouge">/etc/apt/keyrings/docker.asc</code></strong> 파일에 다운로드함.</li>
      <li>GPG 키는 Docker 패키지의 유효성을 확인하는 데 사용됨</li>
      <li><strong><code class="language-plaintext highlighter-rouge">curl</code></strong>: URL로부터 데이터를 다운로드하는 명령입니다.</li>
      <li><strong><code class="language-plaintext highlighter-rouge">fsSL</code></strong>: 다운로드 시에 사용되는 curl 옵션으로, <strong><code class="language-plaintext highlighter-rouge">f</code></strong>, <strong><code class="language-plaintext highlighter-rouge">s</code></strong>, <strong><code class="language-plaintext highlighter-rouge">S</code></strong>, <strong><code class="language-plaintext highlighter-rouge">L</code></strong> 옵션을 사용합니다.
        <ul>
          <li><strong><code class="language-plaintext highlighter-rouge">f</code></strong>: 오류 발생 시 오류 코드를 출력하지 않습니다.</li>
          <li><strong><code class="language-plaintext highlighter-rouge">s</code></strong>: 정적 출력을 사용하여 진행 상황을 표시하지 않습니다.</li>
          <li><strong><code class="language-plaintext highlighter-rouge">S</code></strong>: 오류가 발생한 경우 진행 상황을 출력합니다.</li>
          <li><strong><code class="language-plaintext highlighter-rouge">L</code></strong>: 리다이렉션을 따릅니다.</li>
        </ul>
      </li>
      <li><strong><code class="language-plaintext highlighter-rouge">https://download.docker.com/linux/ubuntu/gpg</code></strong>: Docker의 공식 GPG 키가 위치한 URL입니다.</li>
      <li><strong><code class="language-plaintext highlighter-rouge">o /etc/apt/keyrings/docker.asc</code></strong>: 다운로드된 데이터를 <strong><code class="language-plaintext highlighter-rouge">/etc/apt/keyrings/docker.asc</code></strong> 파일에 저장합니다.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">sudo chmod a+r /etc/apt/keyrings/docker.asc</code></strong>
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">chmod</code></strong>: 파일의 권한을 변경하는 명령입니다.</li>
      <li><strong><code class="language-plaintext highlighter-rouge">a+r</code></strong>: 모든 사용자에게 읽기 권한을 부여하는 옵션입니다. <strong><code class="language-plaintext highlighter-rouge">a</code></strong>는 all(모든 사용자)를 의미하고, <strong><code class="language-plaintext highlighter-rouge">+r</code></strong>은 읽기 권한을 추가한다는 것을 의미합니다.</li>
      <li><strong><code class="language-plaintext highlighter-rouge">/etc/apt/keyrings/docker.asc</code></strong>: 권한을 변경할 파일의 경로입니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">echo \
"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
$(. /etc/os-release &amp;&amp; echo "$VERSION_CODENAME") stable" | \
sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</code> - 첫 번째 줄 : - <strong><code class="language-plaintext highlighter-rouge">echo</code></strong>: 텍스트를 출력하는 명령입니다. - <strong><code class="language-plaintext highlighter-rouge">deb</code></strong>: APT 저장소 설정 파일의 첫 번째 줄로, 저장소의 유형과 주소를 지정합니다. - <strong><code class="language-plaintext highlighter-rouge">[arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc]</code></strong>: 아키텍처와 GPG 키 파일을 지정합니다. 여기서 <strong><code class="language-plaintext highlighter-rouge">dpkg --print-architecture</code></strong> 명령어를 사용하여 시스템의 아키텍처를 가져옵니다. - <strong><code class="language-plaintext highlighter-rouge">https://download.docker.com/linux/ubuntu</code></strong>: Docker의 공식 APT 저장소의 주소입니다. - <strong><code class="language-plaintext highlighter-rouge">$(. /etc/os-release &amp;&amp; echo "$VERSION_CODENAME")</code></strong>: 우분투 버전 코드명을 가져와서 저장소 URL에 포함시킵니다. - <strong><code class="language-plaintext highlighter-rouge">stable</code></strong>: Docker의 안정 버전을 지정합니다. - 두 번째 줄 : - <strong><code class="language-plaintext highlighter-rouge">sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</code></strong>: 앞서 생성한 내용을 <strong><code class="language-plaintext highlighter-rouge">/etc/apt/sources.list.d/docker.list</code></strong> 파일에 기록합니다. <strong><code class="language-plaintext highlighter-rouge">tee</code></strong> 명령어는 표준 출력과 파일 모두에 쓰기를 할 수 있도록 합니다. <strong><code class="language-plaintext highlighter-rouge">&gt; /dev/null</code></strong>은 표준 출력을 무시하도록 합니다. - 세 번째 줄 : - <strong><code class="language-plaintext highlighter-rouge">sudo apt-get update</code></strong>: APT 패키지 목록을 최신 상태로 업데이트합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</code>
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">docker-ce</code></strong>: Docker Community Edition을 설치합니다. 이는 Docker의 컨테이너 실행 엔진입니다.</li>
      <li><strong><code class="language-plaintext highlighter-rouge">docker-ce-cli</code></strong>: Docker CLI(Command Line Interface) 도구를 설치합니다. 이를 통해 Docker 컨테이너 및 이미지를 관리할 수 있습니다.</li>
      <li><strong><code class="language-plaintext highlighter-rouge">containerd.io</code></strong>: 컨테이너 실행을 위한 필수 구성 요소인 containerd를 설치합니다.</li>
      <li><strong><code class="language-plaintext highlighter-rouge">docker-buildx-plugin</code></strong>: Docker의 다중 아키텍처 빌드 기능을 확장하는 플러그인을 설치합니다. 이는 다중 플랫폼 이미지를 빌드하는 데 사용됩니다.</li>
      <li><strong><code class="language-plaintext highlighter-rouge">docker-compose-plugin</code></strong>: Docker Compose를 관리하는 플러그인을 설치합니다. Docker Compose는 여러 컨테이너를 사용하여 복잡한 애플리케이션을 정의하고 실행하는 도구입니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">sudo docker run hello-world</code>
    <ul>
      <li>“hello-world” 이미지를 실행하는 것으로 기본 설치되어 있는 이미지를 실행함으로서 Docker가 정상적으로 설치되었는지 확인하기 위함.</li>
    </ul>
  </li>
</ul>

<h4 id="도커-설치-완료">도커 설치 완료!!</h4>

<hr />

<h2 id="4-docker-이미지-만드는-방법">4. Docker 이미지 만드는 방법</h2>

<p>Dockerfile이라는 것을 만들어야한다.</p>

<hr />

<h2 id="docker-명령어-모음-도커-명령어">Docker 명령어 모음 <a href="https://www.yalco.kr/36_docker/">도커 명령어</a></h2>

<ul>
  <li>
    <h4 id="docker-run-options-image--이미지를-컨테이너에-담아-실행시키는-명령어"><code class="language-plaintext highlighter-rouge">docker run [OPTIONS] [IMAGE]</code> : 이미지를 컨테이너에 담아 실행시키는 명령어</h4>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">docker run httpd</code> : httpd 이미지가 컨테이너에 담겨 실행됨</li>
      <li><code class="language-plaintext highlighter-rouge">docker run --name ws2 httpd</code> =&gt; httpd 이미지가 ws2이름을 가진 컨테이너에 담겨 실행됨</li>
      <li>
        <p>옵션 종류 설명</p>

        <ul>
          <li><code class="language-plaintext highlighter-rouge">--name</code> : 러닝될 컨테이너의 이름이다. 이 옵션을 사용하지 않아서 네임을 지정해주지 않는다면 러닝될 컨테이너의 이름이 랜덤으로 지정된다. 젠킨스가 알아서 네임을 할당하게 되는 것이다.</li>
          <li><code class="language-plaintext highlighter-rouge">-v</code> : 컨테이너 밖의 서버의 디렉토리(볼륨)와 컨테이너 안쪽의 디렉토리(볼륨)을 서로 연결시켜서 연결된 디렉토리 안쪽의<br />
디렉토리와 파일들은 상시 공유된다. 어느 한쪽에서 파일을 생성하거나 삭제하면 둘 다 공유된다.</li>
          <li><code class="language-plaintext highlighter-rouge">-p</code> : 포트포워딩을 하기 위한 옵션. 컨테이너 안쪽의 포트와 컨테이너에 접근하는 바깥쪽의 포트를 매핑시켜준다.</li>
          <li><code class="language-plaintext highlighter-rouge">-d</code> : 컨테이너를 백그라운드에서 실행한다. 거의 매번 붙여주는것이 좋다.</li>
        </ul>
      </li>
      <li>ex) <code class="language-plaintext highlighter-rouge">sudo docker run -d -p 9999:8080 -v /home/ubuntu/jenkins:/var/jenkins_home --name jenkins jenkins/jenkins:lts</code> :
        <ul>
          <li><code class="language-plaintext highlighter-rouge">-d</code>는 컨테이너를 백그라운드에서 실행하겠다는 옵션이다.</li>
          <li><code class="language-plaintext highlighter-rouge">-p</code> 는 포트를 포트포워딩하기 위한 옵션. <code class="language-plaintext highlighter-rouge">9999:8080</code> 형태로 만들어지는데 <code class="language-plaintext highlighter-rouge">8080</code> 은 컨테이너 내부의 포트이고, <code class="language-plaintext highlighter-rouge">9999</code>은 컨테이너 밖에서 접근하기 위한 포트이다. 컨테이너에 <code class="language-plaintext highlighter-rouge">9999</code>번 포트로 접속하면 컨테이너 내부의 <code class="language-plaintext highlighter-rouge">8080</code>번 포트로 연결되는 것이다.</li>
          <li><code class="language-plaintext highlighter-rouge">-v</code>는 volum을 연결하기 위한 것이다. 다시말해 컨테이너 내부의 폴더와 서버의 폴더를 연결하기 위한 것이다. 두 폴더의 내부는 파일들과 구성이 공유된다. <code class="language-plaintext highlighter-rouge">/home/ubuntu/jenkins:/var/jenkins_home</code>를 적으면 서버의 <code class="language-plaintext highlighter-rouge">/home/ubuntu/jenkins</code>폴더와 컨테이너 내부의 <code class="language-plaintext highlighter-rouge">/var/jenkins_home</code>폴더가 공유된다.</li>
        </ul>
      </li>
      <li>맨 마지막에는 실행시킬 이미지명이 들어간다.
<br /><br /><br /></li>
    </ul>
  </li>
  <li>
    <h4 id="docker-ps-options--컨테이너를-보여줌"><code class="language-plaintext highlighter-rouge">docker ps [OPTIONS]</code> : 컨테이너를 보여줌</h4>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">docker ps</code> : 현재 가동중인 컨테이너를 보여줌</li>
      <li><code class="language-plaintext highlighter-rouge">docker ps - a</code> : 중지된 컨테이너까지 보여줌. 컨테이너는 중지됐지만 삭제되지는 않았기 때문
<br /><br /><br /></li>
    </ul>
  </li>
  <li>
    <h4 id="docker-stop-options-container--실행중인-컨테이너를-끄고-싶을-때-사용하는-명령어"><code class="language-plaintext highlighter-rouge">docker stop [OPTIONS] [CONTAINER]</code> : 실행중인 컨테이너를 끄고 싶을 때 사용하는 명령어</h4>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">docker stop ws2</code> : ws2이름을 가진 컨테이너를 중지시킴
<br /><br /><br /></li>
    </ul>
  </li>
  <li>
    <h4 id="docker-start-options-container--중지시켰던-컨테이너를-다시-실행시킬-때-쓰는-명령어"><code class="language-plaintext highlighter-rouge">docker start [OPTIONS] [CONTAINER]</code> : 중지시켰던 컨테이너를 다시 실행시킬 때 쓰는 명령어</h4>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">Docker start ws2</code> : ws2 컨테이너가 실행이 된다. 하지만 이미지를 run 시켰을 때와는 다르게 컨테이너 실행시에 log가 출력되지 않는다
<br /><br /><br /></li>
    </ul>
  </li>
  <li>
    <h4 id="docker-logs-options-container--컨테이너의-로그를-한번만-출력"><code class="language-plaintext highlighter-rouge">Docker logs [OPTIONS] [CONTAINER]</code> : 컨테이너의 로그를 한번만 출력</h4>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Docker logs -f ws2</code> : ws2 컨테이너의 로그를 실시간으로 출력</li>
      <li><code class="language-plaintext highlighter-rouge">Docker logs ws2</code> : ws2 컨테이너의 로그를 실시간으로 출력하지 않고 한번만 출력
<br /><br /><br /></li>
    </ul>
  </li>
  <li>
    <h4 id="docker-rm-options-container--컨테이너를-지움"><code class="language-plaintext highlighter-rouge">Docker rm [OPTIONS] [CONTAINER]</code> : 컨테이너를 지움</h4>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Docker rm ws2</code> : ws2 컨테이너를 지움. 이때 ws2 컨테이너가 중지되어 있어야 함.<br />
즉 stop을 사용하여 컨테이너를 중지한 상태이어야함.</li>
      <li><code class="language-plaintext highlighter-rouge">doekr rm --force ws2</code> : ws2 컨테이너를 중지시키고 삭제시킬때 사용하는 옵션
<br /><br /><br /></li>
    </ul>
  </li>
  <li>
    <h4 id="docker-rmi-options-image--이미지를-지움"><code class="language-plaintext highlighter-rouge">Docker rmi [OPTIONS] [IMAGE]</code> : 이미지를 지움</h4>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Docker rmi httpd</code> : httpd 이름을 가진 이미지를 삭제함.<br />
주로 지우기전에 docker images를 이용하여 지울 이미지들을 확인함
<br /><br /><br /></li>
    </ul>
  </li>
  <li>
    <h4 id="sudo-docker-stop-jenkins--jenkins라는-이름을-가진-컨테이너를-중지함"><code class="language-plaintext highlighter-rouge">sudo docker stop jenkins</code> : jenkins라는 이름을 가진 컨테이너를 중지함.</h4>

    <p><br /><br /><br /></p>
  </li>
  <li>
    <h4 id="sudo-docker-images--docker에-설치된-image들을-확인"><code class="language-plaintext highlighter-rouge">sudo docker images</code> : docker에 설치된 image들을 확인</h4>

    <p><br /><br /><br /></p>
  </li>
  <li>
    <h4 id="sudo-docker-pull-image--docker-hub에서-이미지-다운받기"><code class="language-plaintext highlighter-rouge">sudo docker pull [image]</code> : docker hub에서 이미지 다운받기</h4>
  </li>
  <li>
    <h4 id="docker-exec--it-컨테이너-이름-또는-id--실행할-명령"><code class="language-plaintext highlighter-rouge">docker exec -it [컨테이너 이름 또는 ID]  [실행할 명령]</code></h4>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">-it</code> 옵션을 주지 않으면 쉘이 바로 연결을 끊어버림. <code class="language-plaintext highlighter-rouge">-it</code> 옵션을 주면 쉘 연결이 지속적으로 실행되어 계속 명령을 실행할 수 있는 상태가 됨.</li>
      <li>ex) <code class="language-plaintext highlighter-rouge">docker exec -it jenkins /bin/sh</code> : 젠킨스 컨테이너를 들어가서 쉘로 연결함.</li>
      <li>해당 명령어는 실행중인 컨테이너에만 사용 가능.</li>
      <li><code class="language-plaintext highlighter-rouge">[실행할 명령]</code> 에는 bash, sh 등이 들어올 수 있음. 실행시키고 싶은 쉘 명이 들어감.</li>
    </ul>
  </li>
</ul>
</div>
      </div>
    </div>
    
    <div id="disqus" style="padding: 41px"><div id="disqus_thread"></div>
<script>
    /**
    *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
    *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */
    
    var disqus_config = function () {
    this.page.url = "https://koreamarin.github.io//devops/2024/04/06/Docker/";  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = 'Docker란? 도커 총 정리 및 실습하기'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://koreamarin-github-io.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
    
  </div>
</section>

    </div>
    <footer style='background-color: #eefffd;'>
    <address class="footer_wrap">
        <div class="information">
            <div class="myname">
                Jiwon's Blog
            </div>
            <a href="mailto:awldnjs2@gmail.com" class="email">
                awldnjs2@gmail.com
            </a>
            <div class="accounts">
                <span class="icon">
                    <a class="nav-item" target="_blank" href="https://www.github.com/koreamarin/">
                        <i class="fa fa-github"></i>
                    </a>
                </span>
                
                <!--
                    <span class="icon">
                        <a class="nav-item" target="_blank" href="https://www.twitter.com/username/">
                            <i class="fa fa-twitter"></i>
                        </a>
                    </span>
                -->
            </div>
        </div>
        <div class="copyright">
            <span>
                © koreamarin. <span id="year">2023</span>
            </span>
        </div>    
    </address>
</footer>
    <script src="/js/script.js"></script>
</body>

</html>